#if defined(ESP8266)
  #include <pgmspace.h>
#else
  #include <avr/pgmspace.h>
#endif

extern "C" {
  
  #include "user_interface.h"
  }
  
#include <ESP8266WiFi.h>
#include <ESP8266MqTT.h>
#include "FS.h"

#define MAX_SRV_CLIENTS 8
const char* ssid = "Mobile";
const char* password = "alfafrancesco";

WiFiServer mqtt_server(1883);
WiFiClient mqtt_clients[MAX_SRV_CLIENTS];

#if defined(__SAM3X8E__)
    #undef __FlashStringHelper::F(string_literal)
    #define F(string_literal) string_literal
#endif

//LOG DEFINITION
#define SUPER 3
#define TRACE 2
#define DEBUG 1
#define PROD 0
int LOG_LEVEL=TRACE;
//LOG DEFINITION

//VAR
long t;
long t_msg_scan;
//STATE
int STATE=0;
int subsid_inc=0;
int msgid_inc=0;
boolean event_interrupt=false;

#define MAX_PACKET_LEN 1024
uint8_t IN_PACKET[MAX_PACKET_LEN];

//MQTT
#define MQTTCONNECT     1 << 4  // Client request to connect to Server
#define MQTTCONNACK     2 << 4  // Connect Acknowledgment
#define MQTTPUBLISH     3 << 4  // Publish message
#define MQTTPUBACK      4 << 4  // Publish Acknowledgment
#define MQTTPUBREC      5 << 4  // Publish Received (assured delivery part 1)
#define MQTTPUBREL      6 << 4  // Publish Release (assured delivery part 2)
#define MQTTPUBCOMP     7 << 4  // Publish Complete (assured delivery part 3)
#define MQTTSUBSCRIBE   8 << 4  // Client Subscribe request
#define MQTTSUBACK      9 << 4  // Subscribe Acknowledgment
#define MQTTUNSUBSCRIBE 10 << 4 // Client Unsubscribe request
#define MQTTUNSUBACK    11 << 4 // Unsubscribe Acknowledgment
#define MQTTPINGREQ     12 << 4 // PING Request
#define MQTTPINGRESP    13 << 4 // PING Response
#define MQTTDISCONNECT  14 << 4 // Client is Disconnecting
#define MQTTReserved    15 << 4 // Reserved

#define SESSION_FREE    0
#define SESSION_ALLOCATED    1

struct MQTT_SERVER_SESSION {  

  int State=SESSION_FREE;
  boolean CleanSession;
  String ClientID; 
  long KeepAliveTime;
  long AliveTime;
  };

typedef struct MQTT_SERVER_SESSION mqtt_server_session;
mqtt_server_session SERVER_SESSION[MAX_SRV_CLIENTS];
  
//LOG
void log(int level, String payload){

    if(level<=LOG_LEVEL){
      Serial.printf("[%4d] ",STATE);
      Serial.println(payload);
      }
    }

//SESSION METHOD
void freeSession(int idx){

  SERVER_SESSION[idx].State=SESSION_FREE;
  SERVER_SESSION[idx].ClientID="";
  SERVER_SESSION[idx].KeepAliveTime=0;  
  }

boolean allocSession(int c, String ClientID, long KeepAliveTime){

  if( SERVER_SESSION[c].State==SESSION_FREE ){

    SERVER_SESSION[c].State=SESSION_ALLOCATED;
    SERVER_SESSION[c].ClientID=ClientID;
    SERVER_SESSION[c].KeepAliveTime=KeepAliveTime;
    SERVER_SESSION[c].AliveTime=millis();
    
    {
      char temp[32];
      sprintf(temp,"Client ID has Session @ %d",c);
      log(TRACE,temp);
    }
      
    return true;
    }
    
  return false;
  }
  
void setup() {
  
  Serial.begin(115200); 

  WiFi.begin(ssid, password);
  
  Serial.print("\nConnecting to "); Serial.println(ssid);
  uint8_t i = 0;
  while (WiFi.status() != WL_CONNECTED && i++ < 20) delay(500);
  if(i == 21){
    Serial.print("Could not connect to "); Serial.println(ssid);
    while(1) delay(500);
    }

  mqtt_server.begin();
  mqtt_server.setNoDelay(true);
  
  Serial.print("Ready at ");
  Serial.println(WiFi.localIP());

  for(int i=0;i<MAX_SRV_CLIENTS;i++){

    freeSession(i);
    }


  boolean spiffs = SPIFFS.begin();
  if(spiffs){
    
    log(TRACE,"SPIFFS initialized");

    //LIST PREVIOUS SUBSCRIPTION
    log(TRACE,"List previous SUBSCRIPTIONS");

    fs::Dir dir_data = SPIFFS.openDir("/subs");
    while (dir_data.next()) {
        
      fs::File f = dir_data.openFile("r");
      
      String fname = dir_data.fileName();
      log(TRACE,"Found "+fname);
      
      if(!fname.startsWith("/subs/CS")){
        //remove invalid file here
        f.close();
        SPIFFS.remove(fname);
        
      }else{
        
        {
        char temp[32];
        sprintf(temp,"Subscription> %s - %d",fname.c_str(),f.size());
        log(TRACE,temp);    
        }
        f.close();
        }
      
      }

    dir_data = SPIFFS.openDir("/topic");
    while (dir_data.next()) {
        
      fs::File f = dir_data.openFile("r");
      
      String fname = dir_data.fileName();
      log(TRACE,"Found "+fname);

      {
      char temp[32];
      sprintf(temp,"Message file> %s - %d",fname.c_str(),f.size());
      log(TRACE,temp);    
      }
      f.close();

      if(!fname.endsWith(".new")){

        log(TRACE,"remove> "+fname);
        SPIFFS.remove(fname);
        }
      }
      
    /*
    //CLEAN SUBSCRIPTION
    log(TRACE,"Delete previous SUBSCRIPTIONS");
    fs::Dir dir_data = SPIFFS.openDir("/subs");
    while (dir_data.next()) {
        
      fs::File f = dir_data.openFile("r");
      
      String fname = dir_data.fileName();
      {
      char temp[32];
      sprintf(temp,"Subscription> %s - %d",fname.c_str(),f.size());
      log(TRACE,temp);    
      }
      f.close();
      
      if(SPIFFS.remove(fname)){

        log(TRACE,"File removed");
        }

      }

    */
    }
}
  
void sendData(int idx,uint8_t DATA[], int n){

  Serial.print("Send [ ");
  //int n = sizeof(DATA) / sizeof(uint8_t);
  for(int i=0;i<n;i++){
    {
    char temp[4];
    sprintf(temp,"%x ",DATA[i]);
    Serial.print(temp);
    }
    mqtt_clients[idx].write(DATA[i]);
    }

  Serial.println(" ]");
  //mqtt_clients[idx].flush();
  }

boolean checkMatchTopic(String topic1, String topic2){

  String csv[16];
  int counter = 0;
  int lastIndex = 0;

  String _topic_filter = topic1+"/";
                      
  for (int i=0; i<_topic_filter.length(); i++) {
        
    if (_topic_filter.substring(i, i+1) == "/") {

      if(counter<16)csv[counter] = _topic_filter.substring(lastIndex, i);

        lastIndex = i + 1;
        counter++;
        }
    }

  _topic_filter = topic2+"/";
  counter=0;
  lastIndex = 0;

  boolean match=true;
  for (int i=0; i<_topic_filter.length() && match; i++) {
       
    if (_topic_filter.substring(i, i+1) == "/") {

      if(counter<16){
        String path = _topic_filter.substring(lastIndex, i);
        if(!path.equals("+") && !csv[counter].equals("+") && !path.equals(csv[counter]) )match=false;
        }

      lastIndex = i + 1;
      counter++;
      }
  }
                      
  return match;         
  }
  
void loop() {

  //every minute
  if(millis()-t > 60000){

    t=millis();
    log(TRACE,"Alive");
    }
    
  uint8_t c;
  //check if there are any new clients
  if (mqtt_server.hasClient()){
    for(c = 0; c < MAX_SRV_CLIENTS; c++){
      //find free/disconnected spot
      if (!mqtt_clients[c] || !mqtt_clients[c].connected()){
          if(mqtt_clients[c]) mqtt_clients[c].stop();
        mqtt_clients[c] = mqtt_server.available();

        freeSession(c);
        Serial.print("New client: "); Serial.println(c);
       
        continue;
      }
    }
    //no free/disconnected spot so reject
    WiFiClient mqtt_client = mqtt_server.available();
    mqtt_client.stop();
  }
   
  //check clients for data
  for(c = 0; c < MAX_SRV_CLIENTS; c++){
    if (mqtt_clients[c] && mqtt_clients[c].connected()){
      if(mqtt_clients[c].available()){

        wdt_disable();
        //MQTTSERVER_Parser mqtt_parser(&Serial);
        
        //CLEAN
        for(int y=0;y<MAX_PACKET_LEN;y++)IN_PACKET[y]=0;
        
        int idx=0;        

        Serial.print("Recv [ ");
        //get data from the client and push it to workflow
        while(mqtt_clients[c].available()){

          if(idx<MAX_PACKET_LEN){
            
            IN_PACKET[idx]=mqtt_clients[c].read();
            {
            char temp[32];
            sprintf(temp,"%x ",IN_PACKET[idx]);
            Serial.print(temp);
            }            
            Serial.print(" ");
            idx++;
            }
        
        }      
       
       Serial.println(" ]");
       mqtt_clients[c].flush();

       wdt_enable(20000);
       
       //OK RECEIVED
        {
          char temp[32];
          sprintf(temp,"Session=%02d, Received %d bytes ",c, idx);
          log(TRACE,temp);
        }
        
        if(idx>0){
          
          int control_packet_type=IN_PACKET[0]>>4;

          //rework
          control_packet_type = control_packet_type << 4;
          switch(control_packet_type){
            
            case MQTTCONNECT:
              {
              log(TRACE,"Connect Request Control Packet Received");

              boolean username_flag=false;
              boolean password_flag=false;
              String ClientID="";
              boolean willretain_flag=false;
              int willqos_flag=0x00;
              boolean will_flag=false;
              boolean cleansession_flag=false;  
              int protocol_version=4;
              
              if(IN_PACKET[2]==0 && IN_PACKET[3]==4 && IN_PACKET[4]==int('M') && IN_PACKET[5]==int('Q') && IN_PACKET[6]==int('T') && IN_PACKET[7]==int('T') && IN_PACKET[8]==4){

                log(TRACE,"Receive MqTT 3.1.1 connection request");    

                //check packet flags                
                if( (IN_PACKET[9] && 0x02) !=0 )cleansession_flag=true;
                
                long keep_alive_time = IN_PACKET[10]<<8;
                keep_alive_time+=IN_PACKET[11];
                
                {
                  char temp[32];
                  sprintf(temp,">KeepAliveTime = %ld ",keep_alive_time);
                  log(TRACE,temp);
                }

                //get client ID
                int ClientID_len = IN_PACKET[12]<<8;                
                ClientID_len+=IN_PACKET[13];
                {
                  char temp[32];
                  sprintf(temp,"Client ID length = %d ",ClientID_len);
                  log(TRACE,temp);
                }
                              
                for(int i=0;i < ClientID_len; i++){
                  
                  ClientID+=char(IN_PACKET[14+i]);
                  }
            
                log(TRACE,">ClientID = "+ClientID);
                  
                //flags print
                if(cleansession_flag)log(TRACE,">Clean Session Flag = 1");
                
                //prepare RESPONSE
                uint8_t RC=0x00;
                uint8_t ACK_CONNECT_FLAG = 0x00;

                //disconnect other same ClientID
                for(int i=0;i < MAX_SRV_CLIENTS; i++){

                  //i!=c escludi la current connection
                  if( i!=c && SERVER_SESSION[i].State==SESSION_ALLOCATED && strcmp(ClientID.c_str(), SERVER_SESSION[i].ClientID.c_str())==0){

                    //SP Flag
                    if(!cleansession_flag){

                      log(TRACE,"Set SP flag");
                      ACK_CONNECT_FLAG=ACK_CONNECT_FLAG||0x01;
                      }
                    
                    {
                      char temp[64];
                      sprintf(temp,"Found same Client ID @ %d, force disconnect",i);
                      log(TRACE,temp);
                    }

                    freeSession(i);
                    if (mqtt_clients[i]){

                       log(TRACE,"Send disconnect MqTT packet");

                      //SEND Disconnect Packet
                      uint8_t DISCONNECT_PACKET[2] = {0xE0, 0x00};
                      sendData(i, DISCONNECT_PACKET,2);                
                
                      mqtt_clients[i].flush();                    
                      mqtt_clients[i].stop();
                      }

                    log(TRACE,"Disconnected");
                    }
                  }

                //Alloc SESSION
                if(!allocSession(c, ClientID,keep_alive_time)){

                  log(TRACE,"Connection Refused RC=3");
                  RC=0x03;
                }else{

                  event_interrupt=true;
                  }
                  
                //create RESPONSE
                uint8_t OUT_PACKET[4] = {0x20, 0x02, ACK_CONNECT_FLAG, RC};
                sendData(c, OUT_PACKET,4);                
                }
              
              }              
              break;
            
            case MQTTPINGREQ:
              {
              log(TRACE,"Ping Request Control Packet Received");
              
              {                          
              char temp[64];
              long AliveTime = millis()-SERVER_SESSION[c].AliveTime; 

              sprintf(temp,"Time since last PING %ld ms",AliveTime);
              log(TRACE,temp);
              }

              SERVER_SESSION[c].AliveTime=millis();
              event_interrupt=true;
              
              //create RESPONSE
              uint8_t OUT_PACKET[2] = {0xD0, 0x00};
              sendData(c, OUT_PACKET,2);              
              }
              break;

            case MQTTSUBSCRIBE:
              {
              log(TRACE,"SubScribe Request Control Packet Received");

              String ClientID=SERVER_SESSION[c].ClientID;
              log(TRACE,"Subscribe requested by "+ClientID);

              int pos=0;
              int pid=0;
              int topic_filter_len=0;              
              String topic_filter="";
              uint8_t qos=0;
              
              for(int x=0;x<idx;x++){

                switch(pos){
                  
                  case -1:
                    //something goes wrong, stay wrong
                    break;
                    
                  case 0:
                    {
                    int _control_packet_type=IN_PACKET[0]>>4;

                    //rework
                    _control_packet_type = _control_packet_type << 4;
          
                    if(_control_packet_type == MQTTSUBSCRIBE){

                      log(TRACE,"Receive SUB Request");
                      pos=1;
                      pid=0;
                      topic_filter_len=0;
                      topic_filter="";                      
                      qos=0;
                      }

                    }
                    break;

                  case 1:
                    pos++;
                    break;

                  case 2:
                    //packet id
                    pid = IN_PACKET[x]<<8;                
                    pos++;
                    break;
                    
                  case 3:                  
                    //packet id
                    pid+=IN_PACKET[x];
                    pos++;

                    {
                    char temp[32];
                    sprintf(temp,">Packet ID=%d",pid);
                    log(TRACE,temp);
                    }
                    break;

                  case 4:
                    //topic filter len
                    topic_filter_len = IN_PACKET[x]<<8;                
                    pos++;
                    break;
                    
                  case 5:
                    //topic filter len
                    topic_filter_len+=IN_PACKET[x];
                    pos++;

                    {
                    char temp[32];
                    sprintf(temp,">Topic Filter Len=%d",topic_filter_len);
                    log(TRACE,temp);
                    }
                    
                    break;

                  default:

                    if(topic_filter.length()>=topic_filter_len){
                      
                      //ok topic filter ended, get QoS
                      log(TRACE,">Topic Filter="+topic_filter);

                      qos = IN_PACKET[x];

                      {
                      char temp[32];
                      sprintf(temp,">QoS=%d",qos);
                      log(TRACE,temp);
                      }
                      
                      //make subscription and respond ACK
                      pos=0;

                      int RC=0;
                      log(TRACE,"Generate SubScription");
                      {                      

                      if(topic_filter_len>0){

                        wdt_disable();

                        String target_sub_finename="";
                        {
                        char temp[32];
                        sprintf(temp, "/subs/CS%05d_%ld.sub" , subsid_inc, millis());
                        String target_sub_finename = String(temp);
                        }                       
                        
                        //find subs
                        long t = millis();

                        int checked=0;
                        fs::Dir dir_data = SPIFFS.openDir("/subs");
                        while (dir_data.next()) {

                          //
                          String TOPIC = "";
                          String CLIENTID = "";    
                            
                          fs::File f = dir_data.openFile("r");
      
                          String fname = dir_data.fileName();

                          if(fname.startsWith("/subs/CS")){

                            log(TRACE,"Found "+fname);
                            checked++;

                            int line=0;                            
                            while(f.available()) {
                              
                              String rdline = f.readStringUntil('\n');
                              char buf[rdline.length()];
                              sprintf(buf,"%s",rdline.c_str());
                              buf[rdline.length()-1]='\0';
                              rdline=String(buf);
                              
                              switch(line){

                                case 0:
                                  CLIENTID=String(rdline);
                                  break;

                                case 1:
                                  TOPIC=String(rdline);
                                  break;

                                default:
                                  
                                  break;
                                }
                              
                              line++;
                              }
                            }

                          f.close();
    
                          log(TRACE,"["+CLIENTID+"]["+ClientID+"]-["+TOPIC+"]["+topic_filter+"]");  
                          if( CLIENTID.equals(ClientID) && checkMatchTopic(topic_filter, TOPIC)){
                            
                            //remove old subscription
                            log(TRACE,"Remove "+fname);
                            if(SPIFFS.remove(fname)){

                              log(TRACE,">File removed");
                              //if(cleanSession)
                              //clean session=false;
                              log(TRACE,"Clean Session=false, preserve SUB file name");
                              target_sub_finename = fname;
                              }
                            }
                          }

                        {
                        char temp[32];
                        t = millis()-t;
                        sprintf(temp,"> time find = %ld",t);
                        log(TRACE,temp);                        
                        }

                        t=millis();
                        
                        //Write subscription file
                        {
                        String tmp = "Sub target file is "+target_sub_finename;
                        log(TRACE, tmp);

                        fs::File topicsub_filedat = SPIFFS.open(target_sub_finename, "w");      
                        if (!topicsub_filedat) {
                          log(TRACE,">Problem creating subscription file data");
                        }else{
  
                          log(TRACE,">File is created");                          
                          topicsub_filedat.println(ClientID);
                          topicsub_filedat.println(topic_filter);     
                          topicsub_filedat.println(pid);                     
                          topicsub_filedat.println(qos);                          
                          }
      
                        topicsub_filedat.close();
                        }

                        {
                        char temp[32];
                        t = millis()-t;
                        sprintf(temp,"> time create = %ld",t);
                        log(TRACE,temp);                        
                        }

                        wdt_enable(20000);
                        
                      }else{

                        RC=-1;
                        }
                      }

                      {
                      char temp[32];
                      sprintf(temp,"RC=%d",RC);
                      log(TRACE,temp);
                      }
                      
                      //create RESPONSE
                      uint8_t OUT_PACKET[5] = {0x90, 0x03, 0x00, 0x00, 0x00};
                      //0x03 -> length header var (2 byte) + length payload ( 1 byte)

                      //set PID
                      OUT_PACKET[2]= (uint8_t)(pid >>  8);
                      OUT_PACKET[3]= (uint8_t)(pid >>  0);

                      //set QoS
                      OUT_PACKET[4]= qos;
                      
                      switch(RC){

                        case 0:
                          break;

                        default:
                          OUT_PACKET[4] = 0x80;
                          break;
                        }

                      sendData(c, OUT_PACKET,5);              
                      
                    }else{

                      //inc topic filter
                      topic_filter+=char(IN_PACKET[x]);
                      pos++;
                      }
                                          
                    break;
                  }
                }
              }
              break;

            case MQTTPUBLISH:
              {
              log(TRACE,"Publish message Control Packet Received");
              event_interrupt=true;

              String ClientID=SERVER_SESSION[c].ClientID;
              log(TRACE,"Publish Message requested by "+ClientID);
              
              uint8_t dup=0;
              uint8_t qos=0;
              uint8_t retain=0;  

              if( (IN_PACKET[0] & 0x08))dup=1;
              qos =  (IN_PACKET[0] >> 1) & 0x03;
              if( (IN_PACKET[0] & 0x01))retain=1;

              {
              char temp[32];
              sprintf(temp,">Flag d%d q%d r%d", dup, qos, retain);
              log(TRACE,temp);
              }

              int offset_huge_payload_len=0;
              if(IN_PACKET[1] > 0x7f){

                log(TRACE,"Payload + Header Len is > 128 byte");
                offset_huge_payload_len=1;
                }
                
              int topic_filter_len;
              String topic_filter="";
              
              topic_filter_len = IN_PACKET[offset_huge_payload_len+2]<<8;
              topic_filter_len+=IN_PACKET[offset_huge_payload_len+3];

              {
              char temp[32];
              sprintf(temp,"Topic Filter length = %d ",topic_filter_len);
              log(TRACE,temp);
              }
                              
              for(int i=0;i < topic_filter_len; i++){
                  
                topic_filter+=char(IN_PACKET[offset_huge_payload_len+4+i]);
                }
            
              log(TRACE,">Topic Filter = "+topic_filter);              

              int offset_qos=0;
              if(qos>0)offset_qos=2;

              int payload_len = 0;
              if(offset_huge_payload_len>0){

                int count = IN_PACKET[2];
                payload_len = (0x7f*count) + IN_PACKET[1] - 0x7f - topic_filter_len - offset_qos -2;
                
              }else{
                payload_len = IN_PACKET[1] - topic_filter_len - offset_qos -2;
                }
              
              {
              char temp[32];
              sprintf(temp,"Payload length = %d ",payload_len);
              log(TRACE,temp);
              }
              
              String payload= "";
              
              for(int i=0;i<payload_len;i++){

                payload+=char(IN_PACKET[offset_huge_payload_len+4+topic_filter_len+offset_qos+i]);
                }

              if(payload.length()>32){

                log(TRACE,">Payload = "+payload.substring(0,32)+" ....");        
              }else{
                log(TRACE,">Payload = "+payload);        
                }

              //Store Message & create delivery info
              log(TRACE,"Store msg state");
              String msg_filename = "";
              
              {
              char temp[32];
              sprintf(temp, "/topic/M%05d_%ld" , msgid_inc, millis());
              msg_filename = String(temp);

              String tmp = "MSG file is "+msg_filename;
              log(TRACE, tmp);

              log(TRACE,"Store State");
              fs::File msg_filedat = SPIFFS.open(msg_filename+".st", "w");      
              if (!msg_filedat) {
              
                log(TRACE,">Problem creating msg file data");
              }else{

                //clientid-msgfileid-msgtime-
                msg_filedat.println(ClientID+":"+msg_filename+":"+"0");
                }

              msg_filedat.close();              

              log(TRACE,"Store PAYLOAD");
              msg_filedat = SPIFFS.open(msg_filename+".msg", "w");      
              if (!msg_filedat) {
              
                log(TRACE,">Problem creating msg file data");
              }else{
                
                msg_filedat.println(payload);
                }

              msg_filedat.close();              
              
              }
              
              switch(qos){

                case 0: 
                  {
                  log(TRACE,"Process message QoS=0");
                  wdt_disable();
                  
                  long t=millis();
                  fs::Dir dir_data = SPIFFS.openDir("/subs");
                  while (dir_data.next()) {
        
                    fs::File f =  dir_data.openFile("r");
      
                    String fname = dir_data.fileName();
                    
                    if(fname.startsWith("/subs/CS")){
                    
                      log(TRACE, ">"+fname);    

                      //
                      String TOPIC = "";
                      String CLIENTID = "";    
                            
                      int line=0;                            
                      while(f.available()) {
                              
                        String rdline = f.readStringUntil('\n');
                        char buf[rdline.length()];
                        sprintf(buf,"%s",rdline.c_str());
                        buf[rdline.length()-1]='\0';
                        rdline=String(buf);
                              
                        switch(line){

                          case 0:
                            CLIENTID=String(rdline);
                            break;

                          case 1:
                            TOPIC=String(rdline);
                            break;

                          default:
                                 
                            break;
                            }
                              
                        line++;
                        }

                    //Check if send data
                    if(!CLIENTID.equals(ClientID)){

                      //check topic
                      boolean match = checkMatchTopic(topic_filter, TOPIC);
                      
                      if(match){
                        
                        log(TRACE,"Found Subscription "+TOPIC+" for "+CLIENTID);

                        log(TRACE,"Append data to delivery list");
                        fs::File msg_filedat = SPIFFS.open(msg_filename+".st", "a+");      
                        if (!msg_filedat) {
              
                          log(TRACE,">Problem append data to msg file data");
                        }else{

                          //clientid-subscription file                                             
                          msg_filedat.println(CLIENTID+":"+String(qos)+":"+fname+":"+topic_filter);                          
                          
                          }

                        msg_filedat.close();      
                        }
                      }
                    }
                     
                    f.close();
                    }

                  t = millis()-t;
                  {
                  char temp[32];
                  sprintf(temp,"Scan Subscription Time %d ms", t);
                  log(TRACE,temp);  
                  }
                  
                  wdt_enable(20000);
                  }
                  break;
                  
                default:
                  break;
                }
              }              
              break;
              
            default:
              break;
            }
          }
        

          /*
          int dat = mqtt_clients[i].read();
          mqtt_parser.in(dat);
          char temp[32];
          sprintf(temp,"%x ",dat);
          Serial.write(temp);
          //Serial.write((byte)mqtt_clients[i].read());
          */
          

        /*
        Serial.println("");
        Serial.println("-------");
        
        int packet_type = mqtt_parser.getControlPacketType();
        {
          char temp[32];
          sprintf(temp,"CONTROL PACKET = %d ",packet_type);
          log(TRACE,temp);
        }

        switch(packet_type){

          case 1:
            log(TRACE,"Receive connect packet");
            if(mqtt_parser.isConnectRequest()){

              log(TRACE,"ok");
              long keepalivetime = mqtt_parser.getKeepAliveTime();
              
              {
                char temp[32];
                sprintf(temp,"KeepAliveTime = %ld ",keepalivetime);
                log(TRACE,temp);
              }
              }
            break;

          default:
            break;
          }
        */
      }
    }
  }

  if(millis()-t_msg_scan > 5000 && event_interrupt){

    //flag done
    event_interrupt=false;
    
    t_msg_scan=millis();
    log(TRACE,"Try to deliver msgs");

    wdt_disable();
    
    fs::Dir dir_data = SPIFFS.openDir("/topic");
    while (dir_data.next()) {

      t=millis();
      
      //
      fs::File f = dir_data.openFile("r");
      
      String fname = dir_data.fileName();

      if(fname.startsWith("/topic/M") && fname.endsWith(".st")){

        //Esito
        boolean remove_state_file = false;
        int RC=0;
        
        log(TRACE,"Process "+fname);
        fs::File msg_filedat;

        //retrieve Payload
        log(TRACE,"Get Message Payload");
        String PAYLOAD="";
        
        String msg_filename = fname.substring(0, fname.length()-3);
        log(TRACE,">msg file name payload = "+msg_filename);
        
        msg_filedat = SPIFFS.open(msg_filename+".msg", "r");      
        if (!msg_filedat) {
              
          log(TRACE,">Problem reading msg file data");
          remove_state_file=true;
          RC=-1;
                      
        }else{

          while(msg_filedat.available()) {

            PAYLOAD+=msg_filedat.readStringUntil('\n');
            }
          
          }

        msg_filedat.close();              

        if(PAYLOAD.length()>32){

          log(TRACE,">Payload = "+PAYLOAD.substring(0,32)+" ....");        
        }else{
          log(TRACE,">Payload = "+PAYLOAD);        
          }

        log(TRACE,"Create new target State File");
        //fs::File newmsg_filedat = SPIFFS.open(msg_filename+".new", "w+");  
        
        log(TRACE,"Open State File");
        msg_filedat = SPIFFS.open(fname, "r");      
        
        //read all delivery list
                
        int line=0;      
        long t_line;                      
        while(RC==0 && msg_filedat.available()) {

          t_line=millis();
          
          String rdline = msg_filedat.readStringUntil('\n');
          char buf[rdline.length()];
          sprintf(buf,"%s",rdline.c_str());
          buf[rdline.length()-1]='\0';
          rdline=String(buf);
                              
          switch(line){

            case 0:
              //header line
              //newmsg_filedat.println(rdline);
              
              break;

            default:
              //delivery list          
              log(TRACE,">"+rdline);       

              //process msg
              {
              log(TRACE,"Parse line");
              String csv[16];
              int counter = 0;
              int lastIndex = 0;
            
              String processline = rdline+":";
                                  
              for (int i=0; i<processline.length(); i++) {
                    
                if (processline.substring(i, i+1) == ":") {
            
                  if(counter<16)csv[counter] = processline.substring(lastIndex, i);
            
                    lastIndex = i + 1;
                    counter++;
                    }
                }

              if(counter>=4){
                
                //check if clientid is connected
                log(TRACE,"Check if ClientID "+csv[0]+" has a session");
                
                for(int i=0;i < MAX_SRV_CLIENTS; i++){
                  
                  if( SERVER_SESSION[i].State==SESSION_ALLOCATED && strcmp(csv[0].c_str(), SERVER_SESSION[i].ClientID.c_str())==0){
  
                    log(TRACE,">Client ID is in session");
  
                    if(strcmp(csv[1].c_str(), "0") ==0){
  
                      log(TRACE,"Deliver QoS 0 message");

                      String TOPIC=csv[3];
                      
                      //create RESPONSE
                      log(TRACE,"Create Response Buffer");

                      log(TRACE,">Send to "+TOPIC);
                      //String PAYLOAD = "ABC";
                      int len = 2+TOPIC.length()+PAYLOAD.length();

                      {
                      char temp[16];
                      sprintf(temp,">len=%d ",len);
                      log(TRACE,temp);
                      }

                      //work for remaining length
                      uint8_t REMANING_LEN[2];
                      uint8_t llen = 0;
                      uint8_t digit;
                      unsigned int pos = 0;
                      
                      do {
                          digit = len % 128;
                          len = len / 128;
                          if (len > 0) {
                              digit |= 0x80;
                          }
                          if(pos<2)REMANING_LEN[pos++] = digit;
                          llen++;
                      } while(len>0);

                      //calculate LEN -> header + RemainLength + Topic + 2 + 2 + Payload
                      len = 1+pos+TOPIC.length()+2+PAYLOAD.length();
                      
                      uint8_t OUT_PACKET[len];

                      //HEADER
                      unsigned int p=0;                      
                      OUT_PACKET[p++]=0x30;
                      
                      //REMAIN LENGTH
                      for(int y=0;y<pos;y++){

                        OUT_PACKET[p++]=REMANING_LEN[0];
                        }

                      //TOPIC LENGTH
                      OUT_PACKET[p++]=TOPIC.length() >> 8;
                      OUT_PACKET[p++]=TOPIC.length() & 0xFF;
                      
                      //copy topic to PACKET
                      for(int y=0;y<TOPIC.length();y++){

                        OUT_PACKET[p++]=TOPIC[y];
                        }

                      //COPY PAYLOAD
                      for(int y=0;y<PAYLOAD.length();y++){

                        OUT_PACKET[p++]=PAYLOAD[y];
                        }

                      //PACKET ID
                      //OUT_PACKET[p++]=0xe0;
                      //OUT_PACKET[p++]=0x00;
                      /*
                      for(int y=0;y<len;y++){

                        {
                        char temp[4];
                        sprintf(temp,"%x ",OUT_PACKET[y]);
                        Serial.print(temp);
                        }
                        }
                      Serial.println();
                      */
                      sendData(i, OUT_PACKET,len);  
                      }
  
                  }else{

                    //non consegnato
                    //newmsg_filedat.println(rdline);
                    }
                    
                  }
              }else{

                log(TRACE,"Wrong message state");
                remove_state_file=true;
                }
              }
              
              break;
              }
                              
          line++;

          t_line = millis()-t_line;          
          {
          char temp[32];
          sprintf(temp,"time> %d ms", t_line);
          log(TRACE,temp);  
          }
          t_line = millis();
          
          }
        
        msg_filedat.close();   
        //newmsg_filedat.close();   

        if(!remove_state_file){

          log(TRACE,"Save new State File "+msg_filename+".new -> "+fname );
          //SPIFFS.remove(fname);
          //SPIFFS.rename(msg_filename+".new", fname);
          //SPIFFS.remove(msg_filename+".new");
          }
          
        if(remove_state_file){

          log(TRACE,"Remove State File "+fname);
          SPIFFS.remove(fname);
          }
        }

      t = millis()-t;      
      {
      char temp[32];
      sprintf(temp,"Delivery Message Time %d ms", t);
      log(TRACE,temp);        
      }
      t=millis();
      
      }                

  wdt_enable(20000);
  }
    
}